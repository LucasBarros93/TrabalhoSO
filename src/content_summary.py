class ContentSummary:
    """Cont√©m o resumo te√≥rico sobre sem√°foros e threads."""
    
    @staticmethod
    def show_main_menu():
        """Mostra o menu principal do resumo te√≥rico."""
        print("\n" + "="*60)
        print("üìö RESUMO TE√ìRICO - SEM√ÅFOROS E THREADS")
        print("="*60)
        print("1. üßµ Conceitos B√°sicos de Threads")
        print("2. üö¶ Sem√°foros e Sincroniza√ß√£o")
        print("3. ‚ö†Ô∏è  Problemas Comuns")
        print("4. üêç Threads em Python")
        print("5. üí° Exemplos Pr√°ticos")
        print("0. ‚¨ÖÔ∏è  Voltar ao Menu Principal")
        print("="*60)
    
    @staticmethod
    def show_threads_basics():
        """Explica conceitos b√°sicos de threads."""
        print("\n" + "="*60)
        print("üßµ CONCEITOS B√ÅSICOS DE THREADS")
        print("="*60)
        print("""
üìñ O que s√£o Threads?
   ‚Ä¢ Threads s√£o fluxos de execu√ß√£o independentes dentro de um processo
   ‚Ä¢ Permitem que um programa execute m√∫ltiplas tarefas simultaneamente
   ‚Ä¢ Compartilham o mesmo espa√ßo de mem√≥ria do processo pai

üéØ Vantagens das Threads:
   ‚Ä¢ Melhor aproveitamento de processadores multi-core
   ‚Ä¢ Responsividade: interface n√£o trava enquanto processa dados
   ‚Ä¢ Paraleliza√ß√£o de tarefas independentes
   ‚Ä¢ Menor overhead que criar novos processos

‚ö†Ô∏è  Desafios das Threads:
   ‚Ä¢ Sincroniza√ß√£o: coordenar acesso a recursos compartilhados
   ‚Ä¢ Race conditions: resultados dependem da ordem de execu√ß√£o
   ‚Ä¢ Debugging mais complexo
   ‚Ä¢ Possibilidade de deadlocks

üîÑ Estados de uma Thread:
   ‚Ä¢ NEW: thread criada mas n√£o iniciada
   ‚Ä¢ RUNNABLE: thread em execu√ß√£o ou pronta para executar
   ‚Ä¢ BLOCKED: thread aguardando um recurso
   ‚Ä¢ TERMINATED: thread finalizou sua execu√ß√£o
        """)
        input("\nPressione Enter para continuar...")
    
    @staticmethod
    def show_semaphores():
        """Explica sem√°foros e sincroniza√ß√£o."""
        print("\n" + "="*60)
        print("üö¶ SEM√ÅFOROS E SINCRONIZA√á√ÉO")
        print("="*60)
        print("""
üìñ O que s√£o Sem√°foros?
   ‚Ä¢ Mecanismo de sincroniza√ß√£o para controlar acesso a recursos
   ‚Ä¢ Funcionam como um contador que controla quantas threads podem
     acessar um recurso simultaneamente
   ‚Ä¢ Inventados por Edsger Dijkstra em 1965

üîß Opera√ß√µes Principais:
   ‚Ä¢ acquire() (P): decrementa contador, bloqueia se contador = 0
   ‚Ä¢ release() (V): incrementa contador, libera thread em espera

üìä Tipos de Sem√°foros:
   ‚Ä¢ Bin√°rio (Mutex): contador 0 ou 1, exclus√£o m√∫tua
   ‚Ä¢ Contador: permite N acessos simult√¢neos

üéØ Exclus√£o M√∫tua:
   ‚Ä¢ Garante que apenas uma thread acesse recurso cr√≠tico por vez
   ‚Ä¢ Previne race conditions
   ‚Ä¢ Essencial para integridade dos dados

üíº Casos de Uso:
   ‚Ä¢ Controle de acesso a arquivos
   ‚Ä¢ Limita√ß√£o de conex√µes simult√¢neas
   ‚Ä¢ Sincroniza√ß√£o de threads produtoras/consumidoras
   ‚Ä¢ Prote√ß√£o de vari√°veis globais
        """)
        input("\nPressione Enter para continuar...")
    
    @staticmethod
    def show_common_problems():
        """Explica problemas comuns com threads."""
        print("\n" + "="*60)
        print("‚ö†Ô∏è  PROBLEMAS COMUNS")
        print("="*60)
        print("""
üèÉ‚Äç‚ôÇÔ∏è Race Conditions (Condi√ß√µes de Corrida):
   ‚Ä¢ Ocorrem quando m√∫ltiplas threads acessam dados compartilhados
   ‚Ä¢ O resultado final depende da ordem de execu√ß√£o
   ‚Ä¢ Podem causar corrup√ß√£o de dados
   ‚Ä¢ Solu√ß√£o: usar sem√°foros, mutexes ou locks

üîí Deadlock (Impasse):
   ‚Ä¢ Duas ou mais threads ficam esperando eternamente
   ‚Ä¢ Cada thread possui um recurso que a outra precisa
   ‚Ä¢ Condi√ß√µes necess√°rias:
     - Exclus√£o m√∫tua
     - Reten√ß√£o e espera
     - N√£o preemp√ß√£o
     - Espera circular

üîÑ Livelock:
   ‚Ä¢ Threads n√£o est√£o bloqueadas mas n√£o fazem progresso
   ‚Ä¢ Ficam reagindo umas √†s outras indefinidamente
   ‚Ä¢ Menos comum que deadlock

üò¥ Starvation (Inani√ß√£o):
   ‚Ä¢ Thread nunca consegue acessar o recurso necess√°rio
   ‚Ä¢ Outras threads sempre t√™m prioridade
   ‚Ä¢ Pode causar travamento de funcionalidades espec√≠ficas

üõ°Ô∏è  Estrat√©gias de Preven√ß√£o:
   ‚Ä¢ Ordena√ß√£o de recursos (previne deadlock)
   ‚Ä¢ Timeout em opera√ß√µes de acquire
   ‚Ä¢ Algoritmos de detec√ß√£o e recupera√ß√£o
   ‚Ä¢ Design cuidadoso da sincroniza√ß√£o
        """)
        input("\nPressione Enter para continuar...")
    
    @staticmethod
    def show_python_threading():
        """Explica threads em Python."""
        print("\n" + "="*60)
        print("üêç THREADS EM PYTHON")
        print("="*60)
        print("""
üìö Biblioteca threading:
   ‚Ä¢ M√≥dulo padr√£o do Python para trabalhar com threads
   ‚Ä¢ Fornece classes Thread, Lock, Semaphore, Condition, etc.
   ‚Ä¢ Interface orientada a objetos e f√°cil de usar

üßµ Criando Threads:
   import threading
   
   def minha_funcao():
       print("Executando em thread separada")
   
   thread = threading.Thread(target=minha_funcao)
   thread.start()  # Inicia a thread
   thread.join()   # Aguarda t√©rmino

üö¶ Sem√°foros em Python:
   semaforo = threading.Semaphore(2)  # Permite 2 acessos
   
   semaforo.acquire()  # Adquire permiss√£o
   try:
       # c√≥digo cr√≠tico aqui
       pass
   finally:
       semaforo.release()  # Libera permiss√£o

üîí GIL (Global Interpreter Lock):
   ‚Ä¢ Permite apenas uma thread Python por vez
   ‚Ä¢ Afeta threads CPU-intensivas
   ‚Ä¢ Threads I/O-intensivas ainda se beneficiam
   ‚Ä¢ Use multiprocessing para CPU-intensivas

üí° Boas Pr√°ticas:
   ‚Ä¢ Sempre use try/finally com acquire/release
   ‚Ä¢ Prefira context managers (with statement)
   ‚Ä¢ Evite muitas threads (overhead)
   ‚Ä¢ Use Queue para comunica√ß√£o entre threads
        """)
        input("\nPressione Enter para continuar...")
    
    @staticmethod
    def show_practical_examples():
        """Mostra exemplos pr√°ticos."""
        print("\n" + "="*60)
        print("üí° EXEMPLOS PR√ÅTICOS")
        print("="*60)
        print("""
üè¶ Exemplo: Conta Banc√°ria (Race Condition)
   
   PROBLEMA:
   saldo = 100
   
   Thread 1: saldo = saldo + 50  # Dep√≥sito
   Thread 2: saldo = saldo - 30  # Saque
   
   Sem sincroniza√ß√£o: resultado pode ser incorreto!
   
   SOLU√á√ÉO:
   import threading
   
   lock = threading.Lock()
   saldo = 100
   
   def depositar(valor):
       global saldo
       with lock:
           saldo += valor
   
   def sacar(valor):
       global saldo
       with lock:
           if saldo >= valor:
               saldo -= valor

üçΩÔ∏è  Exemplo: Jantar dos Fil√≥sofos (Deadlock)
   
   PROBLEMA:
   5 fil√≥sofos, 5 garfos, cada um precisa de 2 garfos
   Se todos pegarem o garfo da direita primeiro = DEADLOCK!
   
   SOLU√á√ÉO:
   ‚Ä¢ Numera√ß√£o dos recursos (garfos)
   ‚Ä¢ Sempre pegar o garfo de menor n√∫mero primeiro
   ‚Ä¢ Timeout nas opera√ß√µes
   ‚Ä¢ Waiter (gar√ßom) controlando acesso

üè≠ Exemplo: Produtor-Consumidor
   
   import threading
   import queue
   
   buffer = queue.Queue(maxsize=10)
   
   def produtor():
       for i in range(100):
           buffer.put(f"item_{i}")
   
   def consumidor():
       while True:
           item = buffer.get()
           # processa item
           buffer.task_done()

üåê Casos Reais:
   ‚Ä¢ Servidores web: uma thread por cliente
   ‚Ä¢ Download de arquivos: threads para partes diferentes
   ‚Ä¢ Interface gr√°fica: thread separada para processamento
   ‚Ä¢ Jogos: threads para f√≠sica, renderiza√ß√£o, IA
        """)
        input("\nPressione Enter para continuar...")
    
    @staticmethod
    def show_content(option):
        """Mostra o conte√∫do baseado na op√ß√£o selecionada."""
        if option == "1":
            ContentSummary.show_threads_basics()
        elif option == "2":
            ContentSummary.show_semaphores()
        elif option == "3":
            ContentSummary.show_common_problems()
        elif option == "4":
            ContentSummary.show_python_threading()
        elif option == "5":
            ContentSummary.show_practical_examples()
        else:
            print("‚ùå Op√ß√£o inv√°lida!")
    
    @staticmethod
    def get_full_summary():
        """Retorna todo o conte√∫do te√≥rico formatado para a interface gr√°fica."""
        return """
üßµ CONCEITOS B√ÅSICOS DE THREADS
================================

üìñ O que s√£o Threads?
   ‚Ä¢ Threads s√£o fluxos de execu√ß√£o independentes dentro de um processo
   ‚Ä¢ Permitem que um programa execute m√∫ltiplas tarefas simultaneamente
   ‚Ä¢ Compartilham o mesmo espa√ßo de mem√≥ria do processo pai

üéØ Vantagens das Threads:
   ‚Ä¢ Melhor aproveitamento de processadores multi-core
   ‚Ä¢ Responsividade: interface n√£o trava enquanto processa dados
   ‚Ä¢ Paraleliza√ß√£o de tarefas independentes
   ‚Ä¢ Menor overhead que criar novos processos

‚ö†Ô∏è  Desafios das Threads:
   ‚Ä¢ Sincroniza√ß√£o: coordenar acesso a recursos compartilhados
   ‚Ä¢ Race conditions: resultados dependem da ordem de execu√ß√£o
   ‚Ä¢ Debugging mais complexo
   ‚Ä¢ Possibilidade de deadlocks

üîÑ Estados de uma Thread:
   ‚Ä¢ NEW: thread criada mas n√£o iniciada
   ‚Ä¢ RUNNABLE: thread em execu√ß√£o ou pronta para executar
   ‚Ä¢ BLOCKED: thread aguardando um recurso
   ‚Ä¢ TERMINATED: thread finalizou sua execu√ß√£o


üö¶ SEM√ÅFOROS E SINCRONIZA√á√ÉO
=============================

üìñ O que s√£o Sem√°foros?
   ‚Ä¢ Mecanismo de sincroniza√ß√£o para controlar acesso a recursos
   ‚Ä¢ Mant√©m um contador interno que indica recursos dispon√≠veis
   ‚Ä¢ Inventados por Edsger Dijkstra em 1965

üéØ Objetivo dos Sem√°foros:
   ‚Ä¢ Evitar condi√ß√µes de corrida (race conditions)
   ‚Ä¢ Garantir exclus√£o m√∫tua no acesso a recursos cr√≠ticos
   ‚Ä¢ Coordenar a execu√ß√£o de m√∫ltiplas threads

üîß Opera√ß√µes B√°sicas:
   ‚Ä¢ acquire() ou P(): decrementa contador, bloqueia se for 0
   ‚Ä¢ release() ou V(): incrementa contador, libera threads bloqueadas

üìä Tipos de Sem√°foros:
   ‚Ä¢ Bin√°rio: contador 0 ou 1 (mutex)
   ‚Ä¢ Contagem: contador pode ser qualquer n√∫mero inteiro positivo

üí° Exemplo Conceitual:
   Imagine um estacionamento com 5 vagas:
   ‚Ä¢ Sem√°foro iniciado com valor 5
   ‚Ä¢ Cada carro que entra faz acquire() ‚Üí contador diminui
   ‚Ä¢ Cada carro que sai faz release() ‚Üí contador aumenta
   ‚Ä¢ Se contador = 0, pr√≥ximos carros ficam aguardando


‚ö†Ô∏è  PROBLEMAS COMUNS
====================

üî¥ Race Conditions (Condi√ß√µes de Corrida):
   ‚Ä¢ Ocorrem quando m√∫ltiplas threads acessam dados compartilhados
   ‚Ä¢ O resultado depende da ordem de execu√ß√£o das threads
   ‚Ä¢ Podem causar corrup√ß√£o de dados

üîí Deadlock (Impasse):
   ‚Ä¢ Duas ou mais threads ficam bloqueadas eternamente
   ‚Ä¢ Cada thread espera por um recurso que outra possui
   ‚Ä¢ Condi√ß√µes necess√°rias: exclus√£o m√∫tua, posse e espera, n√£o preemp√ß√£o, espera circular

üîÑ Livelock:
   ‚Ä¢ Threads n√£o ficam bloqueadas, mas tamb√©m n√£o progridem
   ‚Ä¢ Ficam respondendo umas √†s outras indefinidamente

üò¥ Starvation (Inani√ß√£o):
   ‚Ä¢ Uma thread fica indefinidamente sem acesso a um recurso
   ‚Ä¢ Outras threads monopolizam o recurso

üõ°Ô∏è  Como Evitar:
   ‚Ä¢ Use sem√°foros e locks adequadamente
   ‚Ä¢ Sempre adquira recursos na mesma ordem
   ‚Ä¢ Use timeouts em opera√ß√µes de bloqueio
   ‚Ä¢ Minimize o tempo em se√ß√µes cr√≠ticas


üêç THREADS EM PYTHON
====================

üìö Biblioteca threading:
   ‚Ä¢ M√≥dulo padr√£o do Python para trabalhar com threads
   ‚Ä¢ Classe Thread para criar e gerenciar threads
   ‚Ä¢ Sem√°foros, locks, conditions e outros primitivos

üîí GIL (Global Interpreter Lock):
   ‚Ä¢ Permite que apenas uma thread execute c√≥digo Python por vez
   ‚Ä¢ Protege o interpretador, mas limita paralelismo real
   ‚Ä¢ Para CPU intensivo, considere multiprocessing

üíª Criando uma Thread:
import threading

def minha_funcao():
    print("Executando em thread separada")

# Criar e iniciar thread
thread = threading.Thread(target=minha_funcao)
thread.start()
thread.join()  # Aguarda conclus√£o

üì¶ Sem√°foros em Python:
import threading

# Criar sem√°foro com 3 recursos
semaforo = threading.Semaphore(3)

def usar_recurso():
    semaforo.acquire()  # Adquire recurso
    try:
        # Usa o recurso...
        print("Usando recurso")
    finally:
        semaforo.release()  # Libera recurso

üéØ Boas Pr√°ticas:
   ‚Ä¢ Sempre use try/finally com acquire/release
   ‚Ä¢ Use context managers (with statement)
   ‚Ä¢ Evite threads para CPU intensivo (use multiprocessing)
   ‚Ä¢ Para I/O bound, threads s√£o eficientes


üí° EXEMPLOS PR√ÅTICOS
====================

üè¶ Exemplo 1: Conta Banc√°ria Compartilhada
import threading

saldo = 0
lock = threading.Lock()

def depositar(valor):
    global saldo
    with lock:
        temp = saldo
        temp += valor
        saldo = temp

def sacar(valor):
    global saldo
    with lock:
        if saldo >= valor:
            temp = saldo
            temp -= valor
            saldo = temp
            return True
        return False

üè≠ Exemplo 2: Produtor-Consumidor
import threading
import queue

buffer = queue.Queue(maxsize=5)

def produtor():
    for i in range(10):
        item = f"item_{i}"
        buffer.put(item)
        print(f"Produzido: {item}")

def consumidor():
    while True:
        item = buffer.get()
        print(f"Consumido: {item}")
        buffer.task_done()

üéØ Resumo:
   ‚Ä¢ Threads permitem paralelismo em programas
   ‚Ä¢ Sem√°foros controlam acesso a recursos compartilhados
   ‚Ä¢ Cuidado com race conditions e deadlocks
   ‚Ä¢ Python threading √© ideal para I/O bound
   ‚Ä¢ Sempre sincronize acesso a dados compartilhados

üìö Continue estudando e praticando! A programa√ß√£o concorrente √© fundamental
   para criar aplica√ß√µes modernas e eficientes.
        """
